// Copyright 2020-2025 SubQuery Pte Ltd authors & contributors
// SPDX-License-Identifier: GPL-3.0

import type {Address} from '@solana/addresses';
import type {
  TransactionForFullJson,
  UnixTimestamp,
  Blockhash,
  Slot,
  Base58EncodedBytes,
  Lamports,
  TransactionError,
  TransactionStatus,
  TokenBalance,
  Reward,
  Base64EncodedDataResponse,
} from '@solana/rpc-types';
import type {BlockFilter} from '@subql/types-core';

type AddressTableLookup = Readonly<{
  /** public key for an address lookup table account. */
  accountKey: Address;
  /** List of indices used to load addresses of readonly accounts from a lookup table. */
  readableIndexes: readonly number[];
  /** List of indices used to load addresses of writable accounts from a lookup table. */
  writableIndexes: readonly number[];
}>;

type TransactionForFullTransactionAddressTableLookups = Readonly<{
  message: {
    addressTableLookups?: readonly AddressTableLookup[] | null;
  };
}>;

type TransactionForFullTransactionJsonBase = Readonly<{
  message: {
    accountKeys: readonly Address[];
    header: {
      numReadonlySignedAccounts: number;
      numReadonlyUnsignedAccounts: number;
      numRequiredSignatures: number;
    };
    instructions: readonly SolanaInstruction[];
    recentBlockhash: Blockhash;
  };
  signatures: readonly Base58EncodedBytes[];
}>;

type ReturnData = {
  /** the return data itself */
  data: Base64EncodedDataResponse;
  /** the program that generated the return data */
  programId: Address;
};

export type DecodedData<T = any> = {
  name: string;
  data: T;
};

export type LogMessage<T = any> = {
  /** The raw log message **/
  message: string;
  /** */
  decodedMessage?: DecodedData<T>[];
  /** The program address that emitted the message */
  programId: string;
  /** The original index of the unparsed log */
  logIndex: number;

  type: 'log' | 'data' | 'other';
};

type TransactionForFullMetaBase = Readonly<{
  /** number of compute units consumed by the transaction */
  computeUnitsConsumed?: bigint;
  /** Error if transaction failed, null if transaction succeeded. */
  err: TransactionError | null;
  /** fee this transaction was charged */
  fee: Lamports;
  /** parsed log messages, can be null if log recording was not enabled for the message. */
  logs: LogMessage[] | null;
  /** array of account balances after the transaction was processed */
  postBalances: readonly Lamports[];
  /** List of token balances from after the transaction was processed or omitted if token balance recording was not yet enabled during this transaction */
  postTokenBalances?: readonly TokenBalance[];
  /** array of account balances from before the transaction was processed */
  preBalances: readonly Lamports[];
  /** List of token balances from before the transaction was processed or omitted if token balance recording was not yet enabled during this transaction */
  preTokenBalances?: readonly TokenBalance[];
  /** the most-recent return data generated by an instruction in the transaction */
  returnData?: ReturnData;
  /** transaction-level rewards */
  rewards: readonly Reward[] | null;
  /**
   * Transaction status
   * @deprecated
   */
  status: TransactionStatus;
}>;

// type TransactionForFullMetaLoadedAddresses = Readonly<{
//     /** Addresses loaded from lookup tables */
//     loadedAddresses: {
//         readonly: readonly Address[];
//         writable: readonly Address[];
//     };
// }>;

export type TransactionForFullMetaInnerInstructionsUnparsed = Readonly<{
  innerInstructions: readonly Readonly<{
    /** The index of the instruction in the transaction */
    index: number;
    /** The instruction */
    instructions: readonly SolanaInstruction[];
  }>[];
}>;

export type SolanaTransaction = {
  meta: (TransactionForFullMetaBase & TransactionForFullMetaInnerInstructionsUnparsed) | null;
  transaction: TransactionForFullTransactionAddressTableLookups & TransactionForFullTransactionJsonBase;
};

export type SolanaInstruction<T = any> = Readonly<{
  accounts: readonly number[];
  /* The raw instruction data, in base58 encoding */
  data: Base58EncodedBytes;
  /* Decoded instruction data, only present if an IDL is provided or found on the network */
  decodedData?: DecodedData<T>;
  programIdIndex: number;
  stackHeight?: number;

  // Variation from the original @solana/rpc-types to allow linking back to the transaction
  // Use the original pacakge type here so we dont have a circular reference beyond Tx -> Inst -> Tx
  transaction: TransactionForFullJson<void>;
}>;

export type BaseSolanaBlock = Readonly<{
  // From GetBlockApiResponseBase
  /** The number of blocks beneath this block */
  blockHeight: bigint;
  /** Estimated production time, as Unix timestamp */
  blockTime: UnixTimestamp;
  /** the blockhash of this block */
  blockhash: Blockhash;
  /** The slot index of this block's parent */
  parentSlot: Slot;
  /** The blockhash of this block's parent */
  previousBlockhash: Blockhash;
}>;

// Extracted equivalent https://github.com/anza-xyz/kit/blob/main/packages/rpc-api/src/getBlock.ts#L285
export type SolanaBlock = Readonly<
  BaseSolanaBlock & {
    // From GetBlockApiResponseWithTransactions
    transactions: readonly SolanaTransaction[];
  }
>;

export type SolanaBlockFilter = BlockFilter;

/**
 * Represents a filter for Solana Transactions
 * @interface
 * @extends {SolanaTransactionFilter}
 */
export interface SolanaTransactionFilter {
  // TODO could this be multiple addresses?
  /**
   *  The account key of the transaction signer.
   * */
  signerAccountKey?: string;
}

/**
 * Represents a filter for Solana instructions
 * @interface
 * @extends {SolanaInstructionFilter}
 */
export interface SolanaInstructionFilter extends SolanaTransactionFilter {
  /**
   * The account key of the program that is interacted with.
   * @example
   * programId: "11111111111111111111111111111111"
   * */
  programId?: string;

  /**
   * The type of instruction
   * @example
   * type: "transfer
   * */
  type?: string;

  /**
   * Key/value pairs of parsed instruction information specific to the instruction type */
  data?: Record<string, unknown>;
}

/**
 * Represents a filter for Solana logs
 * @interface
 * @extends {SolanaLogFilter}
 */
export interface SolanaLogFilter {
  programId?: string;
}

// export interface EthereumResult extends ReadonlyArray<any> {
//   readonly [key: string]: any;
// }

// export type EthereumBlock = {
//   blockExtraData: string;
//   difficulty: bigint;
//   extDataGasUsed: string;
//   extDataHash: string;
//   gasLimit: bigint;
//   gasUsed: bigint;
//   hash: string;
//   logs: EthereumLog[];
//   logsBloom: string;
//   miner: string;
//   mixHash: string;
//   nonce: string;
//   number: number;
//   parentHash: string;
//   receiptsRoot: string;
//   sha3Uncles: string;
//   size: bigint;
//   stateRoot: string;
//   timestamp: bigint;
//   totalDifficulty: bigint;
//   transactions: EthereumTransaction[];
//   transactionsRoot: string;
//   uncles: string[];
//   baseFeePerGas?: bigint;
//   blockGasCost?: bigint;
// };

// export type EthereumTransaction<T extends EthereumResult = EthereumResult> = {
//   blockHash: string;
//   blockNumber: number;
//   blockTimestamp: bigint;
//   from: string;
//   gas: bigint;
//   gasPrice: bigint;
//   hash: string;
//   input: string;
//   nonce: bigint;
//   to?: string;
//   transactionIndex: bigint;
//   value: bigint;
//   type: string;
//   v: bigint;
//   r: string;
//   s: string;
//   /**
//    * @return {EthereumReceipt} This return type is generic because some networks may return more fields such as OP based networks. This allows your to override the type easily
//    **/
//   receipt: <R extends EthereumReceipt = EthereumReceipt>() => Promise<R>;
//   logs?: EthereumLog[];
//   accessList?: string[];
//   chainId?: string; // Hex string , example: "0x1"
//   maxFeePerGas?: bigint;
//   maxPriorityFeePerGas?: bigint;
//   args?: T;
// };

// export type EthereumReceipt = {
//   blockHash: string;
//   blockNumber: number;
//   contractAddress: string;
//   cumulativeGasUsed: bigint;
//   effectiveGasPrice: bigint;
//   from: string;
//   gasUsed: bigint;
//   logs: EthereumLog[];
//   logsBloom: string;
//   status: boolean;
//   to: string;
//   transactionHash: string;
//   transactionIndex: number;
//   type: string;
// };

// export type EthereumLog<T extends EthereumResult = EthereumResult> = {
//   address: string;
//   topics: string[];
//   data: string;
//   blockHash: string;
//   blockNumber: number;
//   transactionHash: string;
//   transactionIndex: number;
//   logIndex: number;
//   removed: boolean;
//   args?: T;
//   block: EthereumBlock;
//   transaction: EthereumTransaction;
// };

// export type LightEthereumLog<T extends EthereumResult = EthereumResult> = Omit<
//   EthereumLog<T>,
//   'transaction' | 'block'
// > & {
//   block: LightEthereumBlock;
// };

// export type LightEthereumBlock = Omit<EthereumBlock, 'transactions' | 'logs'> & {
//   logs: LightEthereumLog[];
//   transactions: string[];
// };
